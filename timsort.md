# Timsort

### Useful sorces
https://bugs.python.org/file4451/timsort.txt
https://www.baeldung.com/cs/timsort
https://en.wikipedia.org/wiki/Timsort
https://realpython.com/sorting-algorithms-python/#the-timsort-algorithm-in-python



### General idea:
1. linearly divide the given array in sub-arrays of an appropriate length (determined by len(array))
2. use insertion sort on every array
3. merge them in a smart way

### how-s and why-s

Тимсорт был задизайнен для реальных данных. Да, оценки лучших, худших и средних случаев для алгоритмов сортировки в computer science это классно, полезно и вообще -- настоящая математика, но мы здесь собрались, чтобы решать при помощи программ задачи реального мира. И так получается, что многие данные реального мира частично упорядочены или содержат упорядоченные подмассивы, поэтому в алгоритме для реального мира, а не для академической публикации, это хочется утилизировать.
А знаете, что еще мы можем делать с упорядоченными массивами? Соединять их за линейное время!

Окей, тогда идея следующая: давайте искать в массиве упорядоченные подпоследовательности, а потом их мержить. Проблема: у нас нет гарантии, что массив состоит из упорядоченных сегментов. Если мы просто будем делить неупорядоченные сегменты на элементы, то мы приходим к merge sort, и в общем случае ничего не выигрываем. Решение: давайте добавлять наши неупорядоченные кусочки к упорядоченным сегментам, вставляя их в нужное место. Причём лучше даже добавлять сразу несколько элементов, чтобы можно было не повторять какие-то действия для каждого.

Проблема: а как именно вставлять? Решение: сортировкой вставками, потому что на частично упорядоченных массивах она работает быстрее, чем альтернативы (" the time complexity is O(kn) when each element in the input is no more than k places away from its sorted position"). Да, она квадратичная, но она утилизирует упорядоченность, и квадратичность на то и асимптотичная, что разница на малых размерах незначительна. В таком случае, мы теперь умеем готовить подмассивы для слияния, и делать это достаточно быстро, если они частично упорядочены! А ещё сортировка вставками стабильная, поэтому и наша сортировка всё ещё стабильная!

Окей, проблема: а как их теперь эффективно мержить?
Есть несколько проблем: во-первых, мы обязаны мержить последовательные сегменты последовательно, чтобы не нарушить стабильность; во-вторых, хочется утилизировать упрядоченность сегментов, то есть ждать идеально подходящие сегменты, в-третьих, хочется использовать минимальный объем памяти. Если первое -- строгое требование, то между вторым и третьим можно балансировать. 

Тим пришел к следующему компромиссу:
- держим сегменты в стеке; пусть последние три элемента стэка -- \[...ABC\]
- Для них поддерживаем следующее условие:
	1.  |A| > |B| + |C|
	2.  |B| > |C|
- Если нарушается какое-то условие, то мержим меньшее из А и С с B (повторять пока условия не удовлетворяются)
Таким образом мы пытаемся поддерживать длины сегментов для мержа сопоставимыми (так мерж эффективнее), запоминаем для этого необходимый минимум, и поддерживаем стабильность.




